1) 目的

超大容量3Dボリューム（例：256×256×256以上、8 nm/voxel）に対し、GPU/CPUメモリ枯渇やI/Oボトルネックを回避しつつ、安定・再現可能かつ中断再開可能な形で Synapse-Net のセグメンテーション（SV/他）を実行する。さらにインスタンス出力時は、チャンク境界で矛盾のない一貫したラベリングを保証する。

2) 非機能要件（NFR）
	•	再現性：TTA OFF/AMP ON を既定、スレッド数を環境変数で明示制御し、結果のばらつきを低減。
	•	I/O効率：Zarr（チャンク書き）を基本出力として、NFS/圧縮負荷の影響を最小化（NVMe推奨）。

3) 機能要件（FR）
	1.	外部チャンク分割
	•	--chunk_size (cz, cy, cx) と --chunk_halo (hz, hy, hx) を指定し、ハロー込みのROIを切り出し。
	•	ハローは学習時・推論時の受容野を満たすために必要で、貼り戻し時には中心コアのみを使用。
	2.	チャンク内タイル推論
	•	--tile_size と --infer_halo を Synapse-Net CLI に伝達し、GPUメモリに応じた滑り窓推論を実行。
	•	既定：--no_tta --amp --batch_size 1 --labels_only。
	3.	出力と貼り戻し
	•	チャンク出力は TIFF列または Zarr を受け入れ、ハローを除外した中心コアのみをグローバルZarrに貼り戻す。
	•	出力Zarrは labels 配列・任意チャンク形状で作成。
	4.	インスタンスID統合（--instance_mode）
	•	IDオフセット付与：各チャンクで pred[pred>0] += global_offset（next_idを最大IDで更新）し、ID衝突を原理的に排除。
	•	境界統合：チャンク貼り戻し前に、負方向隣接面（-X/-Y/-Z）で merge_band 幅の帯を照合し、接触IDペアを収集。
	•	Union-Find で統合：全チャンク処理後、収集したペアを推移的に結合し、**代表ID（最小ID）**へ正規化。
	•	最終リレーベル：Zarrをチャンク走査して置換マップを適用。--relabel_compact が有効なら 1..K に圧縮。
	•	既定の out_dtype は uint32（ID溢れ対策）。極端なID数は uint64 を許容。
	6.	ログ・メタデータ
	•	meta.json に入出力形状・パラメータを保存、merge_summary.json に統合統計を保存。

4) 設計判断の根拠
	•	外部分割＋中心貼り戻しは、深層モデルの受容野要件を満たしつつ、境界アーチファクトを局在化できる定石的手法。
	•	IDオフセットはID衝突を完全回避し、Union-Findはチャンク列（X/Y/Z方向に跨る）で生じる推移的接続を正しく統合するために必須。
	•	Zarr出力はチャンク単位flushが可能で、長時間ジョブでも部分的成功を積み上げられる。

5) 期待効果とトレードオフ
	•	効果：OOM・スワップ・I/O飽和の回避／安定収束／再開容易／順次可視化・検収が可能。
	•	トレードオフ：
	•	最終リレーベルの追加パスに時間がかかる（ただしNVMe＋チャンク走査で線形時間）。
	•	merge_band を広げるほど統合の網羅性は上がるが、ペア数と処理時間が増えるため、既定は 1 を推奨（必要時のみ 2–3）。

6) 既知の制限と安全策
	•	極端に多いID総数では uint32 を超過しうるため、早期に uint64 を選択できるフラグを提供。
	•	順序依存性はUnion-Findで解消済み（代表IDは最小IDに正規化）で、処理順と無関係に決定的。

7) 推奨初期パラメータ
	•	chunk_size=256×256×96, chunk_halo=16, tile_size=128³, infer_halo=16,
	•	merge_band=1, out_chunks=128×128×64, --no_tta --amp --batch_size 1 --labels_only,
	•	OMP/MKL/OPENBLAS/NUMEXPR=2、出力はZarr（NVMe）。